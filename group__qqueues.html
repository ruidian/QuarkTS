<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="Doxygen Awesome" />
<meta property="og:image" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta property="og:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta name="twitter:title" content="Doxygen Awesome" />
<meta name="twitter:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<!-- END twitter metadata -->
<title>API Reference: Queues</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/svg+xml" href="logo.drawio.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="quarktslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">API Reference
   &#160;<span id="projectnumber">v7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__qqueues.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Queues<div class="ingroups"><a class="el" href="group__qos.html">Operative System</a> &raquo; <a class="el" href="group__qpriv.html">Inter-Task communication</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>API interface to create and handle queues.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structq_queue__t.html">qQueue_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Queue object.  <a href="structq_queue__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0fe9dfcef13b8664e79c240fe3b93fcf"><td class="memItemLeft" align="right" valign="top"><a id="ga0fe9dfcef13b8664e79c240fe3b93fcf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#ga0fe9dfcef13b8664e79c240fe3b93fcf">QUEUE_SEND_TO_BACK</a></td></tr>
<tr class="memdesc:ga0fe9dfcef13b8664e79c240fe3b93fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro directive to indicate whether the item in the queue should be sent to the back. <br /></td></tr>
<tr class="separator:ga0fe9dfcef13b8664e79c240fe3b93fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7336de06f0a222e7d0eab149efda44c"><td class="memItemLeft" align="right" valign="top"><a id="gaa7336de06f0a222e7d0eab149efda44c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#gaa7336de06f0a222e7d0eab149efda44c">QUEUE_SEND_TO_FRONT</a></td></tr>
<tr class="memdesc:gaa7336de06f0a222e7d0eab149efda44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro directive to indicate whether the item in the queue should be sent to the front. <br /></td></tr>
<tr class="separator:gaa7336de06f0a222e7d0eab149efda44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf05b386ccdf3e806474ff7568929f1f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#gadf05b386ccdf3e806474ff7568929f1f">qQueue_SendToBack</a>(obj,  ItemToQueue)</td></tr>
<tr class="memdesc:gadf05b386ccdf3e806474ff7568929f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post an item to the back of the queue. The item is queued by copy, not by reference.  <a href="group__qqueues.html#gadf05b386ccdf3e806474ff7568929f1f">More...</a><br /></td></tr>
<tr class="separator:gadf05b386ccdf3e806474ff7568929f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98aa244c2e878785e48e125ee043d697"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#ga98aa244c2e878785e48e125ee043d697">qQueue_Send</a>(obj,  ItemToQueue)</td></tr>
<tr class="memdesc:ga98aa244c2e878785e48e125ee043d697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post an item to the back of the queue. The item is queued by copy, not by reference.  <a href="group__qqueues.html#ga98aa244c2e878785e48e125ee043d697">More...</a><br /></td></tr>
<tr class="separator:ga98aa244c2e878785e48e125ee043d697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf322ff6707188d3375881200d32d2acf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#gaf322ff6707188d3375881200d32d2acf">qQueue_SendToFront</a>(obj,  ItemToQueue)</td></tr>
<tr class="memdesc:gaf322ff6707188d3375881200d32d2acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post an item in the front of the queue. The item is queued by copy, not by reference.  <a href="group__qqueues.html#gaf322ff6707188d3375881200d32d2acf">More...</a><br /></td></tr>
<tr class="separator:gaf322ff6707188d3375881200d32d2acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4df3615b8cf11f36f7c7d368f24040cc"><td class="memItemLeft" align="right" valign="top"><a id="ga4df3615b8cf11f36f7c7d368f24040cc"></a>
typedef <a class="el" href="group__qtypes.html#ga4b730ac4f14a355d39d1daea0a0b4a54">qUINT8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#ga4df3615b8cf11f36f7c7d368f24040cc">qQueue_Mode_t</a></td></tr>
<tr class="memdesc:ga4df3615b8cf11f36f7c7d368f24040cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typedef to indicate the queue send mode : <a class="el" href="group__qqueues.html#ga0fe9dfcef13b8664e79c240fe3b93fcf" title="A macro directive to indicate whether the item in the queue should be sent to the back.">QUEUE_SEND_TO_BACK</a> or <a class="el" href="group__qqueues.html#gaa7336de06f0a222e7d0eab149efda44c" title="A macro directive to indicate whether the item in the queue should be sent to the front.">QUEUE_SEND_TO_FRONT</a>. <br /></td></tr>
<tr class="separator:ga4df3615b8cf11f36f7c7d368f24040cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf57a0e8f835ed03fcdd8f5372a80ad21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#gaf57a0e8f835ed03fcdd8f5372a80ad21">qQueue_IsReady</a> (const <a class="el" href="structq_queue__t.html">qQueue_t</a> *const obj)</td></tr>
<tr class="memdesc:gaf57a0e8f835ed03fcdd8f5372a80ad21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the queue is already initialized by using <a class="el" href="group__qqueues.html#gaeb0e240ce13f9c76b3bb8bac85ddaf54" title="Configures a Queue. Here, the RAM used to hold the queue data DataArea is statically allocated at com...">qQueue_Setup()</a> API.  <a href="group__qqueues.html#gaf57a0e8f835ed03fcdd8f5372a80ad21">More...</a><br /></td></tr>
<tr class="separator:gaf57a0e8f835ed03fcdd8f5372a80ad21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb0e240ce13f9c76b3bb8bac85ddaf54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#gaeb0e240ce13f9c76b3bb8bac85ddaf54">qQueue_Setup</a> (<a class="el" href="structq_queue__t.html">qQueue_t</a> *const obj, void *DataArea, size_t ItemSize, size_t ItemsCount)</td></tr>
<tr class="memdesc:gaeb0e240ce13f9c76b3bb8bac85ddaf54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures a Queue. Here, the RAM used to hold the queue data <em>DataArea</em> is statically allocated at compile time by the application writer.  <a href="group__qqueues.html#gaeb0e240ce13f9c76b3bb8bac85ddaf54">More...</a><br /></td></tr>
<tr class="separator:gaeb0e240ce13f9c76b3bb8bac85ddaf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eb6ff6ddae7165a58c52ca2ba7f7b9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#ga5eb6ff6ddae7165a58c52ca2ba7f7b9c">qQueue_Reset</a> (<a class="el" href="structq_queue__t.html">qQueue_t</a> *const obj)</td></tr>
<tr class="memdesc:ga5eb6ff6ddae7165a58c52ca2ba7f7b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a queue to its original empty state.  <a href="group__qqueues.html#ga5eb6ff6ddae7165a58c52ca2ba7f7b9c">More...</a><br /></td></tr>
<tr class="separator:ga5eb6ff6ddae7165a58c52ca2ba7f7b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae98b499ea43611b8ac69a2d07959e8c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#gae98b499ea43611b8ac69a2d07959e8c9">qQueue_IsEmpty</a> (const <a class="el" href="structq_queue__t.html">qQueue_t</a> *const obj)</td></tr>
<tr class="memdesc:gae98b499ea43611b8ac69a2d07959e8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the empty status of the Queue.  <a href="group__qqueues.html#gae98b499ea43611b8ac69a2d07959e8c9">More...</a><br /></td></tr>
<tr class="separator:gae98b499ea43611b8ac69a2d07959e8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74486adb8af56225b2477b21658f9222"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#ga74486adb8af56225b2477b21658f9222">qQueue_Count</a> (const <a class="el" href="structq_queue__t.html">qQueue_t</a> *const obj)</td></tr>
<tr class="memdesc:ga74486adb8af56225b2477b21658f9222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of items in the Queue.  <a href="group__qqueues.html#ga74486adb8af56225b2477b21658f9222">More...</a><br /></td></tr>
<tr class="separator:ga74486adb8af56225b2477b21658f9222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06643b2131d073a65efab1965570ddd0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#ga06643b2131d073a65efab1965570ddd0">qQueue_ItemsAvailable</a> (const <a class="el" href="structq_queue__t.html">qQueue_t</a> *const obj)</td></tr>
<tr class="memdesc:ga06643b2131d073a65efab1965570ddd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of available slots to hold items inside the Queue.  <a href="group__qqueues.html#ga06643b2131d073a65efab1965570ddd0">More...</a><br /></td></tr>
<tr class="separator:ga06643b2131d073a65efab1965570ddd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53138962ea9d2986e364cd2f310330e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#ga53138962ea9d2986e364cd2f310330e7">qQueue_IsFull</a> (const <a class="el" href="structq_queue__t.html">qQueue_t</a> *const obj)</td></tr>
<tr class="memdesc:ga53138962ea9d2986e364cd2f310330e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the full status of the Queue.  <a href="group__qqueues.html#ga53138962ea9d2986e364cd2f310330e7">More...</a><br /></td></tr>
<tr class="separator:ga53138962ea9d2986e364cd2f310330e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8beaaa9bc8f5c2de1e85f27da462e9b3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#ga8beaaa9bc8f5c2de1e85f27da462e9b3">qQueue_Peek</a> (const <a class="el" href="structq_queue__t.html">qQueue_t</a> *const obj)</td></tr>
<tr class="memdesc:ga8beaaa9bc8f5c2de1e85f27da462e9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks at the data from the front of the Queue without removing it.  <a href="group__qqueues.html#ga8beaaa9bc8f5c2de1e85f27da462e9b3">More...</a><br /></td></tr>
<tr class="separator:ga8beaaa9bc8f5c2de1e85f27da462e9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26a5df33893013866d659508406019df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#ga26a5df33893013866d659508406019df">qQueue_RemoveFront</a> (<a class="el" href="structq_queue__t.html">qQueue_t</a> *const obj)</td></tr>
<tr class="memdesc:ga26a5df33893013866d659508406019df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the data located at the front of the Queue.  <a href="group__qqueues.html#ga26a5df33893013866d659508406019df">More...</a><br /></td></tr>
<tr class="separator:ga26a5df33893013866d659508406019df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d84fbd48442ceae1b27b218ae33c168"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#ga0d84fbd48442ceae1b27b218ae33c168">qQueue_Receive</a> (<a class="el" href="structq_queue__t.html">qQueue_t</a> *const obj, void *dest)</td></tr>
<tr class="memdesc:ga0d84fbd48442ceae1b27b218ae33c168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive an item from a queue (and removes it). The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created.  <a href="group__qqueues.html#ga0d84fbd48442ceae1b27b218ae33c168">More...</a><br /></td></tr>
<tr class="separator:ga0d84fbd48442ceae1b27b218ae33c168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf917202516511672cb2c0a2db0464de3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#gaf917202516511672cb2c0a2db0464de3">qQueue_SendGeneric</a> (<a class="el" href="structq_queue__t.html">qQueue_t</a> *const obj, void *ItemToQueue, <a class="el" href="group__qqueues.html#ga4df3615b8cf11f36f7c7d368f24040cc">qQueue_Mode_t</a> InsertMode)</td></tr>
<tr class="memdesc:gaf917202516511672cb2c0a2db0464de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post an item to the back of the queue. The item is queued by copy, not by reference.  <a href="group__qqueues.html#gaf917202516511672cb2c0a2db0464de3">More...</a><br /></td></tr>
<tr class="separator:gaf917202516511672cb2c0a2db0464de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79393924bae115e1048b220f12807d40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__qqueues.html#ga79393924bae115e1048b220f12807d40">qTask_Attach_Queue</a> (<a class="el" href="structq_task__t.html">qTask_t</a> *const Task, <a class="el" href="structq_queue__t.html">qQueue_t</a> *const Queue, const <a class="el" href="group__qtaskmanip.html#ga6a915d3ae55fdd4d60c0b4ab54a3fd58">qQueueLinkMode_t</a> Mode, const <a class="el" href="group__qtypes.html#ga8a02cfd33d0381ed5c690db1e385626b">qUINT16_t</a> arg)</td></tr>
<tr class="memdesc:ga79393924bae115e1048b220f12807d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a Queue to the Task.  <a href="group__qqueues.html#ga79393924bae115e1048b220f12807d40">More...</a><br /></td></tr>
<tr class="separator:ga79393924bae115e1048b220f12807d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>API interface to create and handle queues. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga98aa244c2e878785e48e125ee043d697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98aa244c2e878785e48e125ee043d697">&#9670;&nbsp;</a></span>qQueue_Send</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define qQueue_Send</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">obj, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ItemToQueue&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post an item to the back of the queue. The item is queued by copy, not by reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the Queue object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ItemToQueue</td><td>A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from <em>ItemToQueue</em> into the queue storage area. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> on successful add, <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a> if not added. </dd></dl>

</div>
</div>
<a id="gadf05b386ccdf3e806474ff7568929f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf05b386ccdf3e806474ff7568929f1f">&#9670;&nbsp;</a></span>qQueue_SendToBack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define qQueue_SendToBack</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">obj, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ItemToQueue&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post an item to the back of the queue. The item is queued by copy, not by reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the Queue object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ItemToQueue</td><td>A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from <em>ItemToQueue</em> into the queue storage area. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> on successful add, <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a> if not added. </dd></dl>

</div>
</div>
<a id="gaf322ff6707188d3375881200d32d2acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf322ff6707188d3375881200d32d2acf">&#9670;&nbsp;</a></span>qQueue_SendToFront</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define qQueue_SendToFront</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">obj, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ItemToQueue&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post an item in the front of the queue. The item is queued by copy, not by reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the Queue object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ItemToQueue</td><td>A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from <em>ItemToQueue</em> into the queue storage area. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> on successful add, <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a> if not added. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga74486adb8af56225b2477b21658f9222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74486adb8af56225b2477b21658f9222">&#9670;&nbsp;</a></span>qQueue_Count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t qQueue_Count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structq_queue__t.html">qQueue_t</a> *const&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of items in the Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the Queue object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the queue </dd></dl>

</div>
</div>
<a id="gae98b499ea43611b8ac69a2d07959e8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae98b499ea43611b8ac69a2d07959e8c9">&#9670;&nbsp;</a></span>qQueue_IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qQueue_IsEmpty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structq_queue__t.html">qQueue_t</a> *const&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the empty status of the Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the Queue object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> if the Queue is empty, <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a> if it is not. </dd></dl>

</div>
</div>
<a id="ga53138962ea9d2986e364cd2f310330e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53138962ea9d2986e364cd2f310330e7">&#9670;&nbsp;</a></span>qQueue_IsFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qQueue_IsFull </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structq_queue__t.html">qQueue_t</a> *const&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the full status of the Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the Queue object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> if the Queue is full, <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a> if it is not. </dd></dl>

</div>
</div>
<a id="gaf57a0e8f835ed03fcdd8f5372a80ad21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf57a0e8f835ed03fcdd8f5372a80ad21">&#9670;&nbsp;</a></span>qQueue_IsReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qQueue_IsReady </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structq_queue__t.html">qQueue_t</a> *const&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the queue is already initialized by using <a class="el" href="group__qqueues.html#gaeb0e240ce13f9c76b3bb8bac85ddaf54" title="Configures a Queue. Here, the RAM used to hold the queue data DataArea is statically allocated at com...">qQueue_Setup()</a> API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the Queue object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> if the queue is initialized, <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a> if not. </dd></dl>

</div>
</div>
<a id="ga06643b2131d073a65efab1965570ddd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06643b2131d073a65efab1965570ddd0">&#9670;&nbsp;</a></span>qQueue_ItemsAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t qQueue_ItemsAvailable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structq_queue__t.html">qQueue_t</a> *const&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of available slots to hold items inside the Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the Queue object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of available slots in the queue. </dd></dl>

</div>
</div>
<a id="ga8beaaa9bc8f5c2de1e85f27da462e9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8beaaa9bc8f5c2de1e85f27da462e9b3">&#9670;&nbsp;</a></span>qQueue_Peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* qQueue_Peek </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structq_queue__t.html">qQueue_t</a> *const&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks at the data from the front of the Queue without removing it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the Queue object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the data, or NULL if there is nothing in the queue. </dd></dl>

</div>
</div>
<a id="ga0d84fbd48442ceae1b27b218ae33c168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d84fbd48442ceae1b27b218ae33c168">&#9670;&nbsp;</a></span>qQueue_Receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qQueue_Receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_queue__t.html">qQueue_t</a> *const&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive an item from a queue (and removes it). The item is received by copy so a buffer of adequate size must be provided. The number of bytes copied into the buffer was defined when the queue was created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the Queue object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Pointer to the buffer into which the received item will be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> if data was retrieved from the Queue, otherwise returns <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a> </dd></dl>

</div>
</div>
<a id="ga26a5df33893013866d659508406019df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26a5df33893013866d659508406019df">&#9670;&nbsp;</a></span>qQueue_RemoveFront()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qQueue_RemoveFront </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_queue__t.html">qQueue_t</a> *const&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the data located at the front of the Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the Queue object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> if data was removed from the Queue, otherwise returns <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a> </dd></dl>

</div>
</div>
<a id="ga5eb6ff6ddae7165a58c52ca2ba7f7b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5eb6ff6ddae7165a58c52ca2ba7f7b9c">&#9670;&nbsp;</a></span>qQueue_Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qQueue_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_queue__t.html">qQueue_t</a> *const&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets a queue to its original empty state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the Queue object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> on success, otherwise returns <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a>. </dd></dl>

</div>
</div>
<a id="gaf917202516511672cb2c0a2db0464de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf917202516511672cb2c0a2db0464de3">&#9670;&nbsp;</a></span>qQueue_SendGeneric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qQueue_SendGeneric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_queue__t.html">qQueue_t</a> *const&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ItemToQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__qqueues.html#ga4df3615b8cf11f36f7c7d368f24040cc">qQueue_Mode_t</a>&#160;</td>
          <td class="paramname"><em>InsertMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post an item to the back of the queue. The item is queued by copy, not by reference. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__qqueues.html#ga98aa244c2e878785e48e125ee043d697" title="Post an item to the back of the queue. The item is queued by copy, not by reference.">qQueue_Send</a>, <a class="el" href="group__qqueues.html#gaf322ff6707188d3375881200d32d2acf" title="Post an item in the front of the queue. The item is queued by copy, not by reference.">qQueue_SendToFront</a>, <a class="el" href="group__qqueues.html#gadf05b386ccdf3e806474ff7568929f1f" title="Post an item to the back of the queue. The item is queued by copy, not by reference.">qQueue_SendToBack</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the Queue object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ItemToQueue</td><td>A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from <em>ItemToQueue</em> into the queue storage area. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">InsertMode</td><td>Can take the value <a class="el" href="group__qqueues.html#ga0fe9dfcef13b8664e79c240fe3b93fcf" title="A macro directive to indicate whether the item in the queue should be sent to the back.">QUEUE_SEND_TO_BACK</a> to place the item at the back of the queue, or <a class="el" href="group__qqueues.html#gaa7336de06f0a222e7d0eab149efda44c" title="A macro directive to indicate whether the item in the queue should be sent to the front.">QUEUE_SEND_TO_FRONT</a> to place the item at the front of the queue (for high priority messages). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> on successful add, <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a> if not added </dd></dl>

</div>
</div>
<a id="gaeb0e240ce13f9c76b3bb8bac85ddaf54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb0e240ce13f9c76b3bb8bac85ddaf54">&#9670;&nbsp;</a></span>qQueue_Setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qQueue_Setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_queue__t.html">qQueue_t</a> *const&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>DataArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ItemSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ItemsCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures a Queue. Here, the RAM used to hold the queue data <em>DataArea</em> is statically allocated at compile time by the application writer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the Queue object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataArea</td><td>Data block or array of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ItemSize</td><td>The size, in bytes, of one single item in the queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ItemsCount</td><td>The maximum number of items the queue can hold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> on success, otherwise returns <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a>. </dd></dl>

</div>
</div>
<a id="ga79393924bae115e1048b220f12807d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79393924bae115e1048b220f12807d40">&#9670;&nbsp;</a></span>qTask_Attach_Queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__qtypes.html#ga131b2258b5135d0b1e3ded5ecbe309d7">qBool_t</a> qTask_Attach_Queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_task__t.html">qTask_t</a> *const&#160;</td>
          <td class="paramname"><em>Task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structq_queue__t.html">qQueue_t</a> *const&#160;</td>
          <td class="paramname"><em>Queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qtaskmanip.html#ga6a915d3ae55fdd4d60c0b4ab54a3fd58">qQueueLinkMode_t</a>&#160;</td>
          <td class="paramname"><em>Mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__qtypes.html#ga8a02cfd33d0381ed5c690db1e385626b">qUINT16_t</a>&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a Queue to the Task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Task</td><td>Pointer to the task node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Queue</td><td>A pointer to a Queue object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Mode</td><td>Attach mode. This implies the event that will trigger the task according to one of the following modes:</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="group__qtaskmanip.html#gga6a915d3ae55fdd4d60c0b4ab54a3fd58a88ea1fb236aeaf87f62aec4893468628">qQueueMode_Receiver</a> : The task will be triggered if there are elements in the Queue. Data will be extracted automatically in every trigger and will be available in the <a class="el" href="structq_event__t.html#aa8774ca79810e9df25e2743501ee6b74" title="Associated data of the event. Specific data will reside here according to the event source....">qEvent_t::EventData</a> field.</p>
<p><a class="el" href="group__qtaskmanip.html#gga6a915d3ae55fdd4d60c0b4ab54a3fd58a77d2be2a10f114da8faf9c824f2ee4b6">qQueueMode_Full</a> : The task will be triggered if the Queue is full. A pointer to the queue will be available in the <a class="el" href="structq_event__t.html#aa8774ca79810e9df25e2743501ee6b74" title="Associated data of the event. Specific data will reside here according to the event source....">qEvent_t::EventData</a> field.</p>
<p><a class="el" href="group__qtaskmanip.html#gga6a915d3ae55fdd4d60c0b4ab54a3fd58a0c4a64dba03ef78084fb763460048fa6">qQueueMode_Count</a> : The task will be triggered if the count of elements in the queue reach the specified value. A pointer to the queue will be available in the <a class="el" href="structq_event__t.html#aa8774ca79810e9df25e2743501ee6b74" title="Associated data of the event. Specific data will reside here according to the event source....">qEvent_t::EventData</a> field.</p>
<p><a class="el" href="group__qtaskmanip.html#gga6a915d3ae55fdd4d60c0b4ab54a3fd58a4d6ed1f9ed93a18cfd011e0e4d025598">qQueueMode_Empty</a> : The task will be triggered if the queue is empty. A pointer to the queue will be available in the <a class="el" href="structq_event__t.html#aa8774ca79810e9df25e2743501ee6b74" title="Associated data of the event. Specific data will reside here according to the event source....">qEvent_t::EventData</a> field. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>This argument defines if the queue will be attached (<a class="el" href="group__qtypes.html#ga80c5824c1fe206f5d1073857875ec7ca" title="An operation directive that links an object to a task.">qLink</a>) or detached (<a class="el" href="group__qtypes.html#gaee1ceeb4a18bb15dffbd81c28edb1525" title="An operation directive that unlinks an object from a task.">qUnLink</a>) from the task. If the <a class="el" href="group__qtaskmanip.html#gga6a915d3ae55fdd4d60c0b4ab54a3fd58a0c4a64dba03ef78084fb763460048fa6">qQueueMode_Count</a> mode is specified, this value will be used to check the element count of the queue. A zero value will act as a <a class="el" href="group__qtypes.html#gaee1ceeb4a18bb15dffbd81c28edb1525" title="An operation directive that unlinks an object from a task.">qUnLink</a> action. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="group__qtypes.html#ga9cd31c446d7a5ead8f65aa28e4d1f2cd" title="A boolean value that represents true/success/On or High.">qTrue</a> on success, otherwise returns <a class="el" href="group__qtypes.html#gabcfc51cee68e399f81b5c109c8e615c7" title="A boolean value that represents false/failure/Off or Low.">qFalse</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
<script type="text/javascript">
  $(document).ready(function(){
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
  })
</script>
</body>
</html>
